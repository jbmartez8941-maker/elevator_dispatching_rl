import unittest
import numpy as np
from elevator_env import ElevatorEnv
from building import Building, Passenger
from elevator import Elevator

class TestBuilding(unittest.TestCase):
    def setUp(self):
        self.building = Building(num_floors=5, num_elevators=2)

    def test_initialization(self):
        self.assertEqual(self.building.num_floors, 5)
        self.assertEqual(len(self.building.elevators), 2)
        self.assertEqual(len(self.building.waiting_passengers), 5)
        for elevator in self.building.elevators:
            self.assertEqual(elevator.current_floor, 0)
            self.assertEqual(elevator.destination, None)

    def test_passenger_generation(self):
        # Test that passengers are generated properly
        initial_count = sum(len(p) for p in self.building.waiting_passengers.values())
        self.building._generate_passengers()
        new_count = sum(len(p) for p in self.building.waiting_passengers.values())
        self.assertGreaterEqual(new_count, initial_count)

    def test_state_representation(self):
        state = self.building._get_state()
        self.assertIn('elevator_positions', state)
        self.assertIn('waiting_passengers', state)
        self.assertEqual(len(state['elevator_positions']), 2)
        self.assertEqual(len(state['waiting_passengers']), 5)

    def test_action_handling(self):
        # Test valid action
        reward = self.building.take_action((0, 3))  # Move elevator 0 to floor 3
        self.assertIsInstance(reward, float)
        self.assertEqual(self.building.elevators[0].destination, 3)

        # Test invalid elevator ID
        with self.assertRaises(IndexError):
            self.building.take_action((2, 3))  # Invalid elevator ID

class TestElevator(unittest.TestCase):
    def setUp(self):
        self.elevator = Elevator(id=0, num_floors=5, capacity=10, speed=1)

    def test_initialization(self):
        self.assertEqual(self.elevator.current_floor, 0)
        self.assertEqual(self.elevator.destination, None)
        self.assertEqual(self.elevator.direction, 0)
        self.assertEqual(self.elevator.capacity, 10)

    def test_movement(self):
        # Test upward movement
        self.elevator.destination = 3
        self.elevator.move()
        self.assertEqual(self.elevator.current_floor, 1)
        self.assertEqual(self.elevator.direction, 1)

        # Test reaching destination
        self.elevator.current_floor = 3
        self.elevator.move()
        self.assertEqual(self.elevator.destination, None)
        self.assertEqual(self.elevator.direction, 0)

    def test_passenger_handling(self):
        passenger = Passenger(0, 3, spawn_time=0)
        # Test adding passenger
        self.assertTrue(self.elevator.add_passenger(passenger))
        self.assertEqual(len(self.elevator.passengers), 1)

        # Test removing passenger at destination
        self.elevator.current_floor = 3
        departing = self.elevator.remove_passengers()
        self.assertEqual(len(departing), 1)
        self.assertEqual(len(self.elevator.passengers), 0)

class TestElevatorEnv(unittest.TestCase):
    def setUp(self):
        self.env = ElevatorEnv(num_floors=5, num_elevators=2)

    def test_reset(self):
        obs, info = self.env.reset()
        self.assertIsInstance(obs, dict)
        self.assertEqual(obs['elevator_positions'].shape, (2,))
        self.assertEqual(obs['waiting_counts'].shape, (5,))
        self.assertIsInstance(info, dict)

    def test_step(self):
        self.env.reset()
        action = np.array([0, 3])  # Move elevator 0 to floor 3
        obs, reward, done, truncated, info = self.env.step(action)
        
        self.assertIsInstance(obs, dict)
        self.assertIsInstance(reward, float)
        self.assertFalse(done)
        self.assertFalse(truncated)
        self.assertIsInstance(info, dict)
        self.assertIn('total_wait_time', info)
        self.assertIn('elevator_utilization', info)

    def test_observation_space(self):
        obs_space = self.env.observation_space
        self.assertEqual(obs_space['elevator_positions'].shape, (2,))
        self.assertEqual(obs_space['elevator_directions'].shape, (2,))
        self.assertEqual(obs_space['waiting_counts'].shape, (5,))

    def test_action_space(self):
        action_space = self.env.action_space
        self.assertEqual(action_space.nvec.tolist(), [2, 5])  # 2 elevators, 5 floors

class TestPassenger(unittest.TestCase):
    def test_passenger_creation(self):
        p = Passenger(0, 3, spawn_time=10)
        self.assertEqual(p.start_floor, 0)
        self.assertEqual(p.destination, 3)
        self.assertEqual(p.spawn_time, 10)
        self.assertEqual(p.wait_time, 0)

    def test_wait_time_increment(self):
        p = Passenger(0, 3, spawn_time=0)
        p.increment_wait()
        self.assertEqual(p.wait_time, 1)

class TestIntegration(unittest.TestCase):
    def test_full_elevator_trip(self):
        building = Building(5, 1)
        passenger = Passenger(0, 4, 0)
        building.waiting_passengers[0].append(passenger)
        
        # Move elevator to pick up passenger
        building.take_action((0, 0))
        for _ in range(5): building.step()
        
        # Move to destination
        building.take_action((0, 4))
        for _ in range(20): building.step()
        
        self.assertEqual(len(building.elevators[0].passengers), 0)
        self.assertEqual(passenger.wait_time, 5)  # Time to reach floor 0

class TestPerformance(unittest.TestCase):
    def test_large_building_performance(self):
        # Test with larger building to ensure scalability
        env = ElevatorEnv(num_floors=20, num_elevators=5)
        start_time = time.time()
        env.reset()
        for _ in range(100):
            action = env.action_space.sample()
            env.step(action)
        elapsed = time.time() - start_time
        self.assertLess(elapsed, 1.0)  # Should complete in under 1 second

    def test_full_elevator(self):
        elevator = Elevator(0, 5, capacity=2)
        p1 = Passenger(0, 3, 0)
        p2 = Passenger(0, 3, 0)
        p3 = Passenger(0, 3, 0)
        
        self.assertTrue(elevator.add_passenger(p1))
        self.assertTrue(elevator.add_passenger(p2))
        self.assertFalse(elevator.add_passenger(p3))  # Should reject when full

if __name__ == '__main__':
    unittest.main()
